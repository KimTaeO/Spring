## 영속성
* JPA 영속성 컨텍스트란 엔티티를 영구 저장하는 환경을 의미한다
* 데이터베이스와 애플리케이션 사이에서 객체를 보관하는 곳이다
* 객체는 EntityManager를 통해 조회, 저장, 수정, 삭제를 하는 영속성 컨텍스트를 관리한다

### 영속성 컨텍스트에 객체 저장
* EntityManager의 ```persist``` 메서드를 통해 영속성 컨텍스트에 등록이 가능하며, 등록하더라도 DB에는 반영이 되지 않는다(Commit 전)


### 영속성 컨텍스트의 특징
* 영속성 컨텍스트는 논리적인 개념이다
* 영속성 컨텍스트는 EntityManager를 생성할 때 하나씩 만들어지며, EntityManager를 주입받아서 사용한다면, 같은 트랜잭션 범위에 있는 EntityManager는 동일한 영속성 컨텍스트에 접근한다

### 영속성 컨텍스트가 제공하는 기능
1. 1차 캐시: 영속성 컨텍스트 내에는 캐시가 존재하는데 이것을 1차 캐시라고 한다
    * 캐시는 Map 형태로 이루어지며, Key는 Id값 Value는 해당 Entity값이 들어가 있다 따라서 Id이외의 값으로 조회할 경우에는 조회가 되지 않는다

    * 검색 연산을 할 때 1차 캐시에서 엔티티를 찾아 반환하고, 없다면 데이터베이스에서 엔티티를 조회하여 반환하여준다
    
    * 엔티티를 영속화 할때(entityManager.persist(entitiy)) 할때 1차 캐시에 저장된다

    * 트랜잭션의 라이프사이클에 의존된다

2. 동일성 보장: 같은 PK(@Id)를 가진 엔티티에 대해서 동일성을 보장하여준다

    * 같은 참조값을 가지고 있다면 1차 캐시에서 비교를 통해 동일한 값으로 판단한다

    * Id가 같을 경우 객체의 참조가 같아야 true값을 반환하는 ```==```비교를 할 수 있다

3. 트랜잭션을 지원하는 쓰기 지연: 한 트랜잭션이 커밋될 때에 ```INSERT, UPDATE``` SQL이 전송된다

    * 엔티티가 영속화될 때 영속성 컨텍스트의 쓰기 지연 SQL 저장소에 해당 엔티티에 대한 SQL이 생성된다

4. Dirty Checking: 상태 변경 검사라고 할 수 있으며, Jpa에서는 트랜잭션이 끝나는 시점에 엔티티의 변경점을 모두 감지해 데이터베이스에 반영해준다

    *  JPA는 엔티티들을 조회했을 때 스냅샷을 만들어두고, 트랜잭션이 끝나는 시점에 엔티티 상태와 스냅샷이 다르다면 UPDATE 쿼리문을 데이터베이스에 전달한다
        > 단 이러한 변경사항 적용은 영속성 컨테스트가 관리하는 객체에만 적용된다

    * Dirty Checking에서의 UPDATE문은 모든 필드를 업데이트하기 때문에 필드 갯수가 늘어난다면 프로그램에 부담을 줄 수 있다. 이때 ```@DynamicUpdate``` 어노테이션을 사용해 변경점이 생긴 필드만 수정 할 수 있도록 변경 할 수 있다

5. 지연 로딩: 연관된 엔티티를 한꺼번에 조회하지 않고 필요할 시점에 연관된 엔티티를 불러오는 것이다

    * 엔티티를 조회할 때 연관된 엔티티를 조회하지 않고 원본 엔티티를 상속받는 프록시 객체를 반환한다