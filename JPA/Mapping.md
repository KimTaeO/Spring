## 테이블 매핑

### 상속 관계 매핑
* 객체의 상속 관계를 관계형 데이터베이스에 매핑하는것으로 관계형 데이터베이스의 ```슈퍼타입 서브타입```모델링 기법이 객체의 상속 개념과 가장 유사하다
> ORM에서의 상속 관계 매핑은 객체의 상속 개념을 슈퍼타입 서브타입 모델링에 적용하는 것이다

* 이 논리 모델을 물리 모델로 구현할 경우에는 3가지 방법이 있다
    * 각각의 테이블로 변환: 슈퍼타입과 서브타입을 모두 테이블로 만들고 조회할 때 조인을 하는 방식을 물리 모델로 구현한다 JPA에서는 조인 전략이라 한다
    * 통합 테이블로 변환: 테이블을 하나만 사용하여 물리 모델로 구현한다 JPA에서는 단일 테이블 전략이라 한다
    * 서브타입 테이블로 변환: 서브 타입마다 하나의 테이블을 만들어 물리 모델로 구현한다 JPA에서는 구현 클래스마다 테이블 전략이라 한다

* ```@DiscriminatorColumn```을 통하여 부모 클래스에 구분 컬럼을 지정한다
* ```@DiscriminatorValue```을 통하여 자식 클래스의 구분 컬럼에 입력될 값을 지정한다

#### 조인 전략
엔티티 각각을 모두 테이블로 만들고 자식 테이블이 부모 테이블의 기본키를 받아 외래키로 사용하는 동시에 기본키로 사용하는 것이다 이때 주의할 점은 객체는 타입으로 구분할 수 있지만 테이블은 타입의 개념이 없다

* ```@Inheritance(strategy = IheritanceType.JOINED)```를 사용하여 조인 전략임을 나타낸다
* ```@DiscriminatorColumn```을 통하여 부모 클래스에 구분 컬럼을 지정한다
* ```@DiscriminatorValue```을 통하여 자식 클래스의 구분 컬럼에 입력될 값을 지정한다
> 명세로는 ```@DiscriminatorValue```를 사용해야 하지만 몇몇 구현체는 구분 데이터 없이도 동작한다

* 특징
    * 조회할 때 조인이 많이 일어나 속도가 느리다
    * 조회 쿼리가 복잡하다
    * 데이터를 삽입할 때 INSERT 쿼리문이 두번 실행된다

#### 단일 테이블 전략
테이블을 하나만 사용하여 하나의 테이블에 모든 것을 통합한다 구분 컬럼으로 어떤 자식 테이블이 저장되었는지만 구분한다

* ```@Inheritance(strategy = IheritanceType.SINGLE_TABLE)```를 사용하여 단일 테이블 전략임을 나타낸다
* ```@DiscriminatorColumn```을 통하여 부모 클래스에 구분 컬럼을 지정한다
* ```@DiscriminatorValue```을 통하여 자식 클래스의 구분 컬럼에 입력될 값을 지정한다

* 특징
    * 자식엔티티가 매핑한 컬럼은 모두 Null을 허용해야 한다 
    * 조인이 필요하지 않기 때문에 조회 성능이 빠르다
    * 조회 쿼리가 단순하다
    * 단일 테이블에 모든 것을 저장하므로 테이블이 커진다

#### 구현 클래스마다 테이블 전략
자식 엔티티마다 테이블을 만든다 기본적으로 지양하는 방법이다

* 특징 
    * 서브타입을 구분해서 처리할 때 효과적이다
    * 여러 자식 테이블을 한꺼번에 조회할 때 성능이 느리다
    * 자식 테이블을 통합해서 쿼리하기 어렵다
    * 구분 컬럼이 없다

#### @MappedSuperClass
부모 클래스는 테이블과 매핑하지 않고 부모 클래스를 상속받는 자식 클래스에게맨 매핑 정보를 제공하고싶을 때에 사용한다 단순히 매핑 정보를 상속할 목적으로만 사용된다 주로 객체들이 공통적으로 사용하는 매핑 정보들을 담을 수 있다

* 부모로부터 물려받은 매핑 정보를 재정의하기 위해서는 ```@AttributeOverride``` 또는 ```@AttributeOverrides```를 사용한다

* 부모로부터 물려받은 연관관계 정보를 재정의하기 위해서는 ```@AssociationOverride``` 또는 ```@AssociationOverrides```를 사용한다

> 또한 클래스를 직접 생성해 사용할 일이 없기 때문에 추상 클래스로 사용하는것을 권장한다